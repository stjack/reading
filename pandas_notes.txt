1. Selection by position using .loc & .iloc

1) Indexing and select data
https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html

2)Group by

https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html

Group by object
https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.groupby.html


1) Bug of PYODBC
  --below SQL would return NULL using PYODBC because of function index_col used in where condition
  
SQL_INDEX="SELECT      distinct o.name as table_name,i.name as index_name, index_col(o.name, i.indid, c.colid, o.uid) as indexed_column_name, i.status as index_status FROM     sysobjects o     INNER JOIN sysindexes i on i.id = o.id    INNER JOIN syscolumns c on c.id = o.id WHERE o.type='U'  and index_col(o.name, i.indid, c.colid, o.uid) <> null   "


2) Filter pandas with another one-column dataframe

  a.     Group by count of rows, exclude row with count>=1, then change all 'TABLE_NAME' to list , this list will be used as lookup list
   lookup=list(grouped.filter(lambda x: x['TABLE_FLAG'].count() <= 1)['TABLE_NAME'])
===> 
   ['HRI_PS_UBS_GCRS_CUR_VW', 'HRI_PS_UBS_NC_EMP_CUR_VW', ......]
   
  b. Orgin data frame looks like 


   OWNER_x                    TABLE_NAME     OWNER_y     _merge      TABLE_FLAG
  RKYC_DBO        HRI_PS_UBS_GCRS_CUR_VW         NaN  left_only         unknown
  RKYC_DBO      HRI_PS_UBS_NC_EMP_CUR_VW         NaN  left_only         unknown
  RKYC_DBO     HRI_PS_UBS_WORKLOC_CUR_VW         NaN  left_only         unknown
RKYC_EM_01  TCLIENT_RELIANCE_LETTER_JRNL    RKYC_DBO       both  Schema Changed
RKYC_EM_01            TCLIENT_STPPRODBIA    RKYC_DBO       both  Schema Changed
RKYC_EM_01                  TCMMNCT_JRNL    RKYC_DBO       both  Schema Changed
  RKYC_DBO          TSTG_ADDING_PRODUCTS  RKYC_EM_01       both  Schema Changed
  RKYC_DBO                 TSTG_BASECODE  RKYC_EM_01       both  Schema Changed
  RKYC_DBO                TSTG_MIFID_AMD  RKYC_EM_01       both  Schema Changed
  RKYC_DBO                  TSTG_ODI_REP  RKYC_EM_01       both  Schema Changed
RKYC_EM_01   TTRADE_REGULATION_EMIR_JRNL    RKYC_DBO       both  Schema Changed

 c. If value of TABLE_NAME contains any value in list lookup, then keep data , otherwise, NOT keep the row
 -- Using apply + lambda to do this 
 
 tab_out[tab_out['TABLE_NAME'].apply(lambda x: x in lookup)]
 
 
 
 
 2. Pandas TOP N and TOP N in-group
 1) https://stackoverflow.com/questions/36702904/pandas-top-n-rows-top-n-rows-per-group-equivalent-for-row-number-overpartiti

DataFrame:

   dep  manager_id  salary
0    B           5    5005
1    A           6    5001
2    C           8    5000
3    A           7    5000
4    B           0    5002
 
 TOP 5:    df.head(5)
 
 TOP 5, based on sorting columns:
    df.sort_values(by=['manager_id', 'dep'], ascending=[False,True]).head(5)
 
In-Group TOP 2
  ---- top 2 salaries in each department (no duplicates) -----
  --- equivalent for SQL: row_number() over(partition by DEP order by SALARY desc) ---
  
  https://pandas.pydata.org/pandas-docs/stable/reference/groupby.html 
  https://pandas.pydata.org/pandas-docs/stable/reference/frame.html
  
(df.assign(rn=df.sort_values(['salary'], ascending=False)
    .groupby(['dep'])
    .cumcount() + 1)    
    .query('rn < 3') 
    .sort_values(['dep','rn'])
 )
 
 a) Using pd.assign (Assign new columns to a DataFrame.) to generate a new column rn, which represent the in-group sequence of each row
 
 b) cumcount() 
   ### Number each item in each group from 0 to the length of that group - 1. Since value being sorted in-group, so this function will return in-group order number....
   
 c) query 
    ### Dataframe function !!! query column based on boolean expression !!!
 
 ***** Using nlargest groupby function
 df.loc[df.groupby('dep')['salary'].nlargest(2).reset_index()['level_1']]
 
 *****second and third highest salaries in each department  *****
    (df.assign(rn=df.sort_values(['salary'], ascending=False)
        .groupby(['dep'])
        .cumcount() + 1)    
        .query('rn=2' or 'rn=3') ####   ==> return 2nd and 3rd largest 
        .sort_values(['dep','rn'])
     )
 
 
